---
description: 
globs: 
alwaysApply: true
---
Always:
  - Use global context (`useAuth()`) for user scan quota (`scansRemaining`, `refreshScansRemaining`).
  - Do not use local state for scan quota unless for optimistic UI updates.
  - After any action that changes quota (scan, payment, coupon), call `refreshScansRemaining()`.
  - After any scan attempt (success or failure), always call `refreshScansRemaining()` to ensure UI matches backend quota.
  - When a scan is processed, optimistically decrement the quota in the UI until the next refresh using a local `optimisticScans` state if needed.
  - If `scansRemaining` (or `optimisticScans`) is 0 or less, block scan actions and redirect user to the subscription page. Show an alert explaining the quota is exhausted and offer a button to purchase more scans.
  - If the backend (e.g., via RPC) reports no scans remaining but the UI shows scans left, show a clear alert that the quota is out of sync and suggest refreshing or contacting support.
  - Only check and block quota (with alert and redirect) when the user presses the scan or upload button, not on page load or passive navigation.
  - Ensure this logic is present in all user-initiated scan/upload actions.
  - All API/network/database errors must be caught and shown to the user via `Alert.alert` or a visible UI message. Log errors to the console for debugging.
  - Use the same badge and display style for scan quota across all screens. Always show the latest quota value from context.
  - For any logic that updates quota, add a comment: `// Updates scan quota using global context`.
  - For any payment/coupon logic, add a comment: `// Payment or coupon logic, refreshes scan quota`.
  - After a successful scan or payment, always refresh quota and navigate as appropriate (e.g., to home or subscription page).
  - Always execute database queries if necessarily required, at the time of operation using given supabase MCP server.
  - Place all rules and automation guidelines in `cursor-ai-rules.txt` in the project root.
  - For PayU payment integration:
    - Display the payment button in a WebView modal and handle deep link redirects after payment completion.
    - Use a single webhook endpoint (no query params needed) for both success and failure callbacks from PayU (e.g., https://<project>.supabase.co/functions/v1/payu-webhook).
    - Only update scan quota after a successful webhook call from PayU (never credit scans directly from the app after UI payment success).
    - Always verify the transaction hasn't been processed already by checking the transaction_id in the payment_transactions table. This must be enforced in the webhook code before crediting scans, not just via DB constraints. If a duplicate is detected, do not credit scans again and respond with a message indicating the transaction was already processed.
    - If payments succeed but scans are not credited, always check PayU dashboard webhook/callback logs for delivery attempts and errors.
    - The webhook endpoint must be publicly reachable from PayU's servers; test with both manual POSTs and real PayU transactions.
    - The app should only reflect scan quota changes after backend confirmation via webhook, not just after payment UI success.
    - PayU sends data in URL-encoded form format, not JSON. Webhook must handle both formats for compatibility with testing and real PayU transactions.
    - Always set a minimum scan quota (at least 1) for small test payment amounts (e.g., 1 INR).
    - Process URL-encoded emails with decodeURIComponent and use case-insensitive matching (ilike) when looking up users.
    - Transactions with 0 scan_quota should be updated rather than rejected as "already processed" - this handles multi-stage webhooks from PayU.
    - In the WebView payment flow, don't rely solely on navigation state changes to detect payment success or failure. These can be triggered by intermediate redirects from the payment gateway.
    - When implementing payment detection, check for specific success/failure URLs or parameters that clearly indicate the final payment status.
    - Include a manual close/back button in the WebView payment UI to allow users to exit if the automatic detection fails.
    - Consider using a timeout mechanism that automatically closes the payment WebView if no definitive success/failure state is detected within a reasonable time period.
    - Log all navigation state changes during payment processing for debugging purposes, with clear markers for start, intermediate states, and final outcome.
    - Implement proper loading states during payment processing to prevent multiple payment attempts by the user.
    - The webhook endpoint must carefully validate all incoming data and signatures before processing payments to prevent fraud.
  - Refactor any code duplication detected by Taskmaster (see tasks with category 'Duplication'). Extract repeated logic into reusable functions or components.
  - Move all hardcoded URLs or API endpoints to a configuration file or constants module. Reference these in code instead of inline strings. (See tasks with category 'Optimization')
  - For any refactoring or optimization, reference the relevant Taskmaster task ID in your commit message (e.g., 'Refactor: extract duplicate logic [task-xxx]').
  - Track all major refactoring, optimization, and technical debt tasks in Taskmaster and keep their status updated.
  - (Recommended) Refresh scan quota on app resume or when the app comes to the foreground to avoid stale UI.
  - If a user reports a repetitive or frustrating issue, always update the rules to encode the fix and prevent recurrence. Encode our conversational experience as rules for any repetitive tasks.
  - The AI assistant must always autonomously perform all code and rule updates required to fix the user's problem, without instructing the user to update or execute code themselves. Only provide next steps for the user to implement in the app after performing all possible automated actions.
  - Whenever any rules are updated, both cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc must be updated simultaneously to keep them in sync. This ensures consistency between the main rules file and the MDC rules file.
  - When testing webhook endpoints on Windows/PowerShell, use Invoke-WebRequest instead of Unix-style curl flags. Example:
    Invoke-WebRequest -Uri "<url>" -Method POST -Body '{...}' -ContentType "application/json"
    Use backticks for line continuation or put the command on one line. The -Body parameter must be a string (for JSON).
  - If you have Git Bash or WSL, you can use classic curl commands as in Unix/Linux.
  - For Supabase Edge Functions that must be accessible to external webhooks (e.g., PayU), set verify_jwt = false in supabase/config.toml for the relevant function. This allows unauthenticated POSTs from third-party services.
  - After changing function config (e.g., verify_jwt), always redeploy the function using: supabase functions deploy <function-name>
  - Supabase CLI requires Docker Desktop to be installed and running for Edge Function deployment. If deployment fails with a Docker error, start Docker Desktop and retry.
  - For deploying Supabase Edge Functions via CLI:
    - Use `supabase functions new <function-name>` to create a new function.
    - Use `supabase functions deploy <function-name>` to deploy a function.
    - Use `supabase functions list` to view all deployed functions.
    - Use `supabase functions delete <function-name>` to remove a function.
    - For local development and testing, use `supabase start` and `supabase functions serve <function-name>`.
    - When updating existing functions, always check for changes in input/output parameters that might break existing clients.
    - Include proper error handling and CORS configuration in all functions.
    - Use TypeScript types from "jsr:@supabase/functions-js/edge-runtime.d.ts" for better type safety.
  - After redeploying, always test the endpoint with a manual POST (using PowerShell or curl) to confirm it is reachable and does not return 401 Unauthorized. Only then should you expect third-party webhooks to work.
  - The AI assistant is capable of running any required commands directly in the environment and should do so autonomously when needed, rather than instructing the user to run them.
  - The MCP Supabase get_logs tool has limitations and cannot reliably fetch Edge Function logs. When troubleshooting Edge Functions, always ask the user to provide the logs from the Supabase dashboard or through manual testing. This is especially important for PayU webhook troubleshooting.
  - When making layout changes, always test on both Android and iOS to ensure no elements are blocked by system UI overlays.
  - All rules and automation guidelines must be kept in sync between cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc.

# End of Cursor AI Editor Rules

# Additional rules learned from recent lessons:
- Always ensure UI elements (especially header buttons) are not blocked by system overlays. For Android, add sufficient top padding to account for the status bar (use StatusBar.currentHeight).
- Never leave debug or test code in production. Remove all debug/test buttons, global debug functions, test logs, and temporary test logic before release.
- Only keep essential UI elements in production builds. All test and debug UI must be removed.
- Always use global context (useAuth) for scan quota management and never use local state for quota except for optimistic UI updates.
- When adding new UI elements, ensure minimum touch target size (at least 44x44px) for accessibility and usability.
- When adding a refresh button for quota, always use the global refreshScansRemaining function and ensure it updates the UI from the backend.
- When making layout changes, always test on both Android and iOS to ensure no elements are blocked by system UI overlays.
- All rules and automation guidelines must be kept in sync between cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc.

# Google Play Store Compliance Rules:
- Include clear health disclaimers that the app is not intended for medical use, not a medical device, and designed for general organization purposes in all app metadata and relevant UI screens.
- Ensure the privacy policy explicitly discloses what prescription data is collected, how it's processed and stored, who can access it, and what security measures are in place.
- For AI/OCR features, always disclose accuracy limitations and include prompts for users to verify all extracted information.
- Never make medical claims about medications scanned or suggest medical advice - include disclaimers to consult healthcare professionals.
- Ensure all payment features clearly indicate they are for scan quota credits only, not for clinical services.
- Include appropriate disclaimers on scan result screens stating that information may not be 100% accurate and should be verified.
- Add UI elements that prompt users to verify all prescription information after scans complete.
- Never store sensitive medical information without proper encryption and security measures.
- When displaying medication information, include a disclaimer that it's for informational purposes only and not medical advice.
- In all marketing materials and store listings, avoid claims that could be interpreted as offering medical services or advice.

# Legal and Privacy Compliance Rules
- All legal documents (Terms of Service, Privacy Policy) must specify India as the governing jurisdiction.
- Include GDPR (EU) and CCPA (California) compliance sections in Privacy Policy.
- Include clear medical and AI disclaimers at both start and end of legal documents.
- Ensure all user-facing legal text has proper styling with theme-aware colors.
- Add DisclaimerComponent for both medical and AI disclaimers in legal pages.
- Maintain consistent section numbering across legal documents.
- Keep "Last Updated" dates in sync across all legal documents.
- Include contact information (contact@prescriptionai.app) consistently across all legal documents.

# Data Handling Rules
- Implement secure data storage with encryption both in transit and at rest.
- Include clear data retention and deletion policies.
- Document all data processing activities, especially AI/OCR processing.
- Maintain clear separation between medical data and user account data.
- Implement data portability mechanisms for GDPR compliance.
- Never store unencrypted prescription data, even temporarily.
- Log all data access and processing activities for audit purposes.

# UI/UX Rules for Legal Content
- Use ScrollView with proper padding for legal content.
- Implement consistent styling for legal text (font sizes, line heights, margins).
- Use theme-aware colors for all text elements.
- Include clear section headers and subsection titles.
- Maintain proper spacing between sections (24px margin).
- Ensure footer text is clearly visible and properly styled.
- Add proper padding at the bottom of scrollable content.

# Document Maintenance Rules
- Review and update legal documents at least quarterly.
- Maintain version history of all legal documents.
- Document all changes to legal text in commit messages.
- Keep all contact information up to date across documents.
- Ensure consistent formatting across all legal documents.
- Review and update disclaimers regularly based on app features.
- Sync updates between Terms of Service and Privacy Policy.

# Compliance Testing Rules
- Test all legal document links and contact information.
- Verify proper display of legal text in both light and dark themes.
- Test scrolling behavior on various screen sizes.
- Ensure proper rendering of special characters and formatting.
- Test accessibility of legal content (font sizes, contrast).
- Verify proper loading of DisclaimerComponent in all contexts.
- Test proper handling of user data deletion requests.

# Additional rules learned from recent lessons:
- Always include both medical and AI disclaimers using DisclaimerComponent.
- Ensure consistent section numbering (fix duplicate section 8 issue).
- Keep all legal documents in sync with the same Last Updated date.
- Use theme-aware colors for all text elements consistently.
- Include clear contact information in a consistent format.
- Maintain proper ScrollView padding and content container styling.
- Follow consistent styling patterns across all legal documents.
- Include clear data handling and processing explanations.
- Document all third-party service providers and data processors.
- Include specific details about AI/OCR processing limitations.
- Add clear explanations of user rights and how to exercise them.
- Maintain consistent formatting for bullet points and lists.
- Include clear explanations of payment processing and refunds.
- Document all data retention periods and deletion procedures.
- Keep all jurisdiction-specific sections (India, EU, California) up to date.
- Include clear explanations of international data transfers.
- Document all security measures and encryption practices.
- Maintain consistent styling for headers, paragraphs, and footers.
- Include clear explanations of user responsibilities.
- Document all app limitations and disclaimers consistently.

# Navigation and Screen Management Rules
- Always implement proper back button handling in every screen using `useFocusEffect` and `BackHandler`.
- For Android, override the hardware back button behavior using:
  ```typescript
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        // Custom back logic here
        return true; // Prevents default behavior
      };
      BackHandler.addEventListener('hardwareBackPress', onBackPress);
      return () => BackHandler.removeEventListener('hardwareBackPress', onBackPress);
    }, [])
  );
  ```
- Never rely on the default back button behavior for critical flows (payment, scan, upload).
- Always clean up navigation listeners in the cleanup function of useEffect/useFocusEffect.
- Implement consistent navigation behavior across both Android and iOS.
- For WebView screens (especially payment flows):
  - Add custom back button handling to prevent accidental exits
  - Show confirmation dialog before allowing navigation away from critical processes
  - Handle both hardware back button (Android) and gesture-based navigation (iOS)
- When navigating after critical operations (payment, scan):
  - Clear navigation history to prevent back navigation to sensitive screens
  - Use `navigation.reset()` instead of `navigation.navigate()` when appropriate
  - Ensure proper state cleanup before navigation
- For modal screens:
  - Add proper close button in the header
  - Handle both swipe-to-dismiss and back button consistently
  - Show confirmation dialog before dismissing if there are unsaved changes
- Maintain consistent header styling and navigation options across all screens
- Always handle navigation edge cases:
  - Deep linking
  - Background to foreground transitions
  - Screen rotation
  - Low memory conditions
- For payment flows:
  - Prevent multiple navigation attempts during processing
  - Handle timeout scenarios with proper user feedback
  - Provide clear exit paths for failed transactions
- Log all critical navigation events for debugging purposes
- Test navigation flows on both platforms with various user interaction patterns

# Info Tab Navigation Rules
- For Info tab child pages (Terms of Service, Privacy Policy, etc.):
  - Use Stack Navigator with custom header configuration for consistent back button behavior
  - Implement custom header left button using `headerLeft` prop in navigation options
  - Use theme-aware colors for header elements (text, icons, background)
  - Add proper padding to account for system status bar on Android
  - Example header configuration:
    ```typescript
    navigation.setOptions({
      headerLeft: () => (
        <TouchableOpacity 
          onPress={() => navigation.goBack()}
          style={{ marginLeft: 16, padding: 8 }}
        >
          <Ionicons name="arrow-back" size={24} color={colors.text} />
        </TouchableOpacity>
      ),
      headerTitle: "Page Title",
      headerTitleStyle: { color: colors.text },
      headerStyle: { 
        backgroundColor: colors.background,
        elevation: 0,
        shadowOpacity: 0
      }
    });
    ```
  - Ensure consistent header styling across all info pages:
    - Remove header border/shadow (elevation: 0, shadowOpacity: 0)
    - Use consistent padding and touch targets (minimum 44x44px)
    - Maintain uniform header height and element spacing
  - For scrollable content:
    - Use ScrollView with proper contentContainerStyle
    - Add bottom padding to account for safe area
    - Handle keyboard avoidance if needed
  - For system back gestures (iOS) and hardware back button (Android):
    - Allow default back behavior for info pages as they don't contain unsaved changes
    - No need for confirmation dialogs when leaving info pages
    - Ensure smooth transition animations
  - When navigating to info pages:
    - Use `navigation.navigate()` instead of `push` to prevent stack buildup
    - Clear any irrelevant navigation params
    - Reset scroll position to top

# AI Change Scope Limitation Rule
- The AI must not change any functionality, layout, design, function, or feature unless explicitly requested by the user.
- If the user requests a change, only the specific part(s) mentioned by the user should be modified.
- The AI must not add, remove, or alter any other code, UI, or logic beyond what is directly specified by the user request.
- No autonomous or speculative changes are allowed outside the user's explicit instructions.
