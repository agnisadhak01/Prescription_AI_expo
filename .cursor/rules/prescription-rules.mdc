---
description: 
globs: 
alwaysApply: true
---
Always:
  - Use global context (`useAuth()`) for user scan quota (`scansRemaining`, `refreshScansRemaining`).
  - Do not use local state for scan quota unless for optimistic UI updates.
  - After any action that changes quota (scan, payment, coupon), call `refreshScansRemaining()`.
  - After any scan attempt (success or failure), always call `refreshScansRemaining()` to ensure UI matches backend quota.
  - When a scan is processed, optimistically decrement the quota in the UI until the next refresh using a local `optimisticScans` state if needed.
  - If `scansRemaining` (or `optimisticScans`) is 0 or less, block scan actions and redirect user to the subscription page. Show an alert explaining the quota is exhausted and offer a button to purchase more scans.
  - If the backend (e.g., via RPC) reports no scans remaining but the UI shows scans left, show a clear alert that the quota is out of sync and suggest refreshing or contacting support.
  - Only check and block quota (with alert and redirect) when the user presses the scan or upload button, not on page load or passive navigation.
  - Ensure this logic is present in all user-initiated scan/upload actions.
  - All API/network/database errors must be caught and shown to the user via `Alert.alert` or a visible UI message. Log errors to the console for debugging.
  - Use the same badge and display style for scan quota across all screens. Always show the latest quota value from context.
  - For any logic that updates quota, add a comment: `// Updates scan quota using global context`.
  - For any payment/coupon logic, add a comment: `// Payment or coupon logic, refreshes scan quota`.
  - After a successful scan or payment, always refresh quota and navigate as appropriate (e.g., to home or subscription page).
  - Always execute database queries if necessarily required, at the time of operation using given supabase MCP server.
  - Place all rules and automation guidelines in `cursor-ai-rules.txt` in the project root.
  - For PayU payment integration:
    - Display the payment button in a WebView modal and handle deep link redirects after payment completion.
    - Use a single webhook endpoint (no query params needed) for both success and failure callbacks from PayU (e.g., https://<project>.supabase.co/functions/v1/payu-webhook).
    - Only update scan quota after a successful webhook call from PayU (never credit scans directly from the app after UI payment success).
    - Always verify the transaction hasn't been processed already by checking the transaction_id in the payment_transactions table. This must be enforced in the webhook code before crediting scans, not just via DB constraints. If a duplicate is detected, do not credit scans again and respond with a message indicating the transaction was already processed.
    - If payments succeed but scans are not credited, always check PayU dashboard webhook/callback logs for delivery attempts and errors.
    - The webhook endpoint must be publicly reachable from PayU's servers; test with both manual POSTs and real PayU transactions.
    - The app should only reflect scan quota changes after backend confirmation via webhook, not just after payment UI success.
    - PayU sends data in URL-encoded form format, not JSON. Webhook must handle both formats for compatibility with testing and real PayU transactions.
    - Always set a minimum scan quota (at least 1) for small test payment amounts (e.g., 1 INR).
    - Process URL-encoded emails with decodeURIComponent and use case-insensitive matching (ilike) when looking up users.
    - Transactions with 0 scan_quota should be updated rather than rejected as "already processed" - this handles multi-stage webhooks from PayU.
  - Refactor any code duplication detected by Taskmaster (see tasks with category 'Duplication'). Extract repeated logic into reusable functions or components.
  - Move all hardcoded URLs or API endpoints to a configuration file or constants module. Reference these in code instead of inline strings. (See tasks with category 'Optimization')
  - For any refactoring or optimization, reference the relevant Taskmaster task ID in your commit message (e.g., 'Refactor: extract duplicate logic [task-xxx]').
  - Track all major refactoring, optimization, and technical debt tasks in Taskmaster and keep their status updated.
  - (Recommended) Refresh scan quota on app resume or when the app comes to the foreground to avoid stale UI.
  - If a user reports a repetitive or frustrating issue, always update the rules to encode the fix and prevent recurrence. Encode our conversational experience as rules for any repetitive tasks.
  - The AI assistant must always autonomously perform all code and rule updates required to fix the user's problem, without instructing the user to update or execute code themselves. Only provide next steps for the user to implement in the app after performing all possible automated actions.
  - Whenever any rules are updated, both cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc must be updated simultaneously to keep them in sync. This ensures consistency between the main rules file and the MDC rules file.
  - When testing webhook endpoints on Windows/PowerShell, use Invoke-WebRequest instead of Unix-style curl flags. Example:
    Invoke-WebRequest -Uri "<url>" -Method POST -Body '{...}' -ContentType "application/json"
    Use backticks for line continuation or put the command on one line. The -Body parameter must be a string (for JSON).
  - If you have Git Bash or WSL, you can use classic curl commands as in Unix/Linux.
  - For Supabase Edge Functions that must be accessible to external webhooks (e.g., PayU), set verify_jwt = false in supabase/config.toml for the relevant function. This allows unauthenticated POSTs from third-party services.
  - After changing function config (e.g., verify_jwt), always redeploy the function using: supabase functions deploy <function-name>
  - Supabase CLI requires Docker Desktop to be installed and running for Edge Function deployment. If deployment fails with a Docker error, start Docker Desktop and retry.
  - After redeploying, always test the endpoint with a manual POST (using PowerShell or curl) to confirm it is reachable and does not return 401 Unauthorized. Only then should you expect third-party webhooks to work.
  - The AI assistant is capable of running any required commands directly in the environment and should do so autonomously when needed, rather than instructing the user to run them.
  - The MCP Supabase get_logs tool has limitations and cannot reliably fetch Edge Function logs. When troubleshooting Edge Functions, always ask the user to provide the logs from the Supabase dashboard or through manual testing. This is especially important for PayU webhook troubleshooting.

# End of Cursor AI Editor Rules
