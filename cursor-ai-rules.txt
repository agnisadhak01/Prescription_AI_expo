---
description: |
  Standardized rules for Cursor AI Editor in this project. These rules automate and enforce best practices for scan quota, error handling, UI, navigation, refactoring, and optimization in the Prescription app.
globs:
  - '**/*.tsx'
  - '**/*.ts'
alwaysApply: true
---
Always:
  - Use global context (`useAuth()`) for user scan quota (`scansRemaining`, `refreshScansRemaining`).
  - Do not use local state for scan quota unless for optimistic UI updates.
  - After any action that changes quota (scan, payment, coupon), call `refreshScansRemaining()`.
  - After any scan attempt (success or failure), always call `refreshScansRemaining()` to ensure UI matches backend quota.
  - When a scan is processed, optimistically decrement the quota in the UI until the next refresh using a local `optimisticScans` state if needed.
  - If `scansRemaining` (or `optimisticScans`) is 0 or less, block scan actions and redirect user to the subscription page. Show an alert explaining the quota is exhausted and offer a button to purchase more scans.
  - If the backend (e.g., via RPC) reports no scans remaining but the UI shows scans left, show a clear alert that the quota is out of sync and suggest refreshing or contacting support.
  - Only check and block quota (with alert and redirect) when the user presses the scan or upload button, not on page load or passive navigation.
  - Ensure this logic is present in all user-initiated scan/upload actions.
  - All API/network/database errors must be caught and shown to the user via `Alert.alert` or a visible UI message. Log errors to the console for debugging.
  - Use the same badge and display style for scan quota across all screens. Always show the latest quota value from context.
  - For any logic that updates quota, add a comment: `// Updates scan quota using global context`.
  - For any payment/coupon logic, add a comment: `// Payment or coupon logic, refreshes scan quota`.
  - After a successful scan or payment, always refresh quota and navigate as appropriate (e.g., to home or subscription page).
  - Always execute database queries if necessarily required, at the time of operation using given supabase MCP server.
  - Place all rules and automation guidelines in `cursor-ai-rules.txt` in the project root.
  - For PayU payment integration:
    - Display the payment button in a WebView modal and handle deep link redirects after payment completion.
    - Use a single webhook endpoint (no query params needed) for both success and failure callbacks from PayU (e.g., https://<project>.supabase.co/functions/v1/payu-webhook).
    - Only update scan quota after a successful webhook call from PayU (never credit scans directly from the app after UI payment success).
    - Always verify the transaction hasn't been processed already by checking the transaction_id in the payment_transactions table. This must be enforced in the webhook code before crediting scans, not just via DB constraints. If a duplicate is detected, do not credit scans again and respond with a message indicating the transaction was already processed.
    - If payments succeed but scans are not credited, always check PayU dashboard webhook/callback logs for delivery attempts and errors.
    - The webhook endpoint must be publicly reachable from PayU's servers; test with both manual POSTs and real PayU transactions.
    - The app should only reflect scan quota changes after backend confirmation via webhook, not just after payment UI success.
    - PayU sends data in URL-encoded form format, not JSON. Webhook must handle both formats for compatibility with testing and real PayU transactions.
    - Always set a minimum scan quota (at least 1) for small test payment amounts (e.g., 1 INR).
    - Process URL-encoded emails with decodeURIComponent and use case-insensitive matching (ilike) when looking up users.
    - Transactions with 0 scan_quota should be updated rather than rejected as "already processed" - this handles multi-stage webhooks from PayU.
    - In the WebView payment flow, don't rely solely on navigation state changes to detect payment success or failure. These can be triggered by intermediate redirects from the payment gateway.
    - When implementing payment detection, check for specific success/failure URLs or parameters that clearly indicate the final payment status.
    - Include a manual close/back button in the WebView payment UI to allow users to exit if the automatic detection fails.
    - Consider using a timeout mechanism that automatically closes the payment WebView if no definitive success/failure state is detected within a reasonable time period.
    - Log all navigation state changes during payment processing for debugging purposes, with clear markers for start, intermediate states, and final outcome.
    - Implement proper loading states during payment processing to prevent multiple payment attempts by the user.
    - The webhook endpoint must carefully validate all incoming data and signatures before processing payments to prevent fraud.
  - Refactor any code duplication detected by Taskmaster (see tasks with category 'Duplication'). Extract repeated logic into reusable functions or components.
  - Move all hardcoded URLs or API endpoints to a configuration file or constants module. Reference these in code instead of inline strings. (See tasks with category 'Optimization')
  - For any refactoring or optimization, reference the relevant Taskmaster task ID in your commit message (e.g., 'Refactor: extract duplicate logic [task-xxx]').
  - Track all major refactoring, optimization, and technical debt tasks in Taskmaster and keep their status updated.
  - (Recommended) Refresh scan quota on app resume or when the app comes to the foreground to avoid stale UI.
  - If a user reports a repetitive or frustrating issue, always update the rules to encode the fix and prevent recurrence. Encode our conversational experience as rules for any repetitive tasks.
  - The AI assistant must always autonomously perform all code and rule updates required to fix the user's problem, without instructing the user to update or execute code themselves. Only provide next steps for the user to implement in the app after performing all possible automated actions.
  - Whenever any rules are updated, both cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc must be updated simultaneously to keep them in sync. This ensures consistency between the main rules file and the MDC rules file.
  - When testing webhook endpoints on Windows/PowerShell, use Invoke-WebRequest instead of Unix-style curl flags. Example:
    Invoke-WebRequest -Uri "<url>" -Method POST -Body '{...}' -ContentType "application/json"
    Use backticks for line continuation or put the command on one line. The -Body parameter must be a string (for JSON).
  - If you have Git Bash or WSL, you can use classic curl commands as in Unix/Linux.
  - For Supabase Edge Functions that must be accessible to external webhooks (e.g., PayU), set verify_jwt = false in supabase/config.toml for the relevant function. This allows unauthenticated POSTs from third-party services.
  - After changing function config (e.g., verify_jwt), always redeploy the function using: supabase functions deploy <function-name>
  - Supabase CLI requires Docker Desktop to be installed and running for Edge Function deployment. If deployment fails with a Docker error, start Docker Desktop and retry.
  - For deploying Supabase Edge Functions via CLI:
    - Use `supabase functions new <function-name>` to create a new function.
    - Use `supabase functions deploy <function-name>` to deploy a function.
    - Use `supabase functions list` to view all deployed functions.
    - Use `supabase functions delete <function-name>` to remove a function.
    - For local development and testing, use `supabase start` and `supabase functions serve <function-name>`.
    - When updating existing functions, always check for changes in input/output parameters that might break existing clients.
    - Include proper error handling and CORS configuration in all functions.
    - Use TypeScript types from "jsr:@supabase/functions-js/edge-runtime.d.ts" for better type safety.
  - After redeploying, always test the endpoint with a manual POST (using PowerShell or curl) to confirm it is reachable and does not return 401 Unauthorized. Only then should you expect third-party webhooks to work.
  - The AI assistant is capable of running any required commands directly in the environment and should do so autonomously when needed, rather than instructing the user to run them.
  - The MCP Supabase get_logs tool has limitations and cannot reliably fetch Edge Function logs. When troubleshooting Edge Functions, always ask the user to provide the logs from the Supabase dashboard or through manual testing. This is especially important for PayU webhook troubleshooting.

# Additional rules learned from recent lessons:
- Always ensure UI elements (especially header buttons) are not blocked by system overlays. For Android, add sufficient top padding to account for the status bar (use StatusBar.currentHeight).
- Never leave debug or test code in production. Remove all debug/test buttons, global debug functions, test logs, and temporary test logic before release.
- Only keep essential UI elements in production builds. All test and debug UI must be removed.
- Always use global context (useAuth) for scan quota management and never use local state for quota except for optimistic UI updates.
- When adding new UI elements, ensure minimum touch target size (at least 44x44px) for accessibility and usability.
- When adding a refresh button for quota, always use the global refreshScansRemaining function and ensure it updates the UI from the backend.
- When making layout changes, always test on both Android and iOS to ensure no elements are blocked by system UI overlays.
- All rules and automation guidelines must be kept in sync between cursor-ai-rules.txt and .cursor/rules/prescription-rules.mdc.

# Google Play Store Compliance Rules:
- Include clear health disclaimers that the app is not intended for medical use, not a medical device, and designed for general organization purposes in all app metadata and relevant UI screens.
- Ensure the privacy policy explicitly discloses what prescription data is collected, how it's processed and stored, who can access it, and what security measures are in place.
- For AI/OCR features, always disclose accuracy limitations and include prompts for users to verify all extracted information.
- Never make medical claims about medications scanned or suggest medical advice - include disclaimers to consult healthcare professionals.
- Ensure all payment features clearly indicate they are for scan quota credits only, not for clinical services.
- Include appropriate disclaimers on scan result screens stating that information may not be 100% accurate and should be verified.
- Add UI elements that prompt users to verify all prescription information after scans complete.
- Never store sensitive medical information without proper encryption and security measures.
- When displaying medication information, include a disclaimer that it's for informational purposes only and not medical advice.
- In all marketing materials and store listings, avoid claims that could be interpreted as offering medical services or advice.

# End of Cursor AI Editor Rules 